\section{Heuristics and augmentation of SAT solvers}
To evaluate the performance of a heuristically augmented SAT solver on PRCPSP-ST instances comparative data needs to be generated.  To make sure the variables between algorithms are limited they were all designed, implemented and run on the same hardware for this research. This way the at least coding skills and hardware improvements over time are not introduced in the data. Improved performance of new algorithms only as a result of the use of more recent hardware has shown up in the past as described in section \ref{section:responsible research}. Three algorithms are used to solve the same problem instances for an equal amount of time: a heuristic algorithm, SAT solver, heuristically augmented SAT solver.

The heuristic algorithm is an adapted version of the iterated greedy algorithm \cite{RN32}. It was designed for flow-shop scheduling but with a few tweaks it can also be applied to RCPSP.

For a SAT solver to be used the PRCPSP-ST has to be encoded into conjunctive normal form boolean logic. When the encoding is made any SAT solver is able to provide feasible schedules. Because there is a clear objective to reduce the makespan a more advanced MAX-SAT solver is used. This will create feasible schedules while also trying to optimize to an objective function.

To augment a SAT solver for a specific problem the code of the solver has to be changed. In the case of this research a heuristic function will be added that improves the selection of a possible variable. The heuristic function will use knowledge about PRCPSP-ST to try and select a variable that will reduce the resulting schedule makespan.

\subsection{Heuristic}
As a heuristic solution a tweaked version of the iterated greedy algorithm is implemented \cite{RN32}. This algorithm requires an activity list representation of the project. It start with a setup of an initial schedule and then iterates over a destruction phase and a construction phase until a time limit or number of iterations limit is reached. 

An activity list representation allows a serial generation scheme to construct a feasible schedule \cite{RN46}. The activity list represent a project as permutation vector of all the tasks. It is required that no task appears in the list after any of its successors. The serial generation scheme schedules all the task in the order of the list at the earliest possible start time that does not break precedence or resource restrictions. Because the generation scheme uses the tasks in order of the list tasks close to the front of the list can be seen as having a higher priority and are scheduled sooner by the algorithm. When the algorithm has scheduled all tasks the result is a left-justified schedule.

The initial schedule is generated with the use of a greedy heuristic. Firstly a resource utility rate \(u_i\) is calculated for each task 
\begin{equation}
u_i=\frac{d_i \times r_{i,k}}{a_k} 
\end{equation}
For each task its resource requirement is divided by the resource availability. The result is multiplied by the task duration. Next all tasks are put into a list and ordered by non-increasing resource utility rate. After ordering each task is moved directly in front of the first successor in the list. The result is an activity list representation and the serial generation scheme is run on it to create the initial (left-justified) schedule.

After the initial list is generated the main iterative part of the algorithm starts with the destruction phase. During this phase a copy is made of the initial schedule and next \(d=\lceil\frac{|N|}{4}\rceil\)  tasks are removed from the activity list at random. These are picked one by one and are kept separately in the order they were removed.

The second step of the main iteration is the construction phase. From the removed tasks the first is picked and placed at any index in the remaining activity list that doesn't break the precedence order. For each possible index the makespan of the left-justified schedule made with the serial generation scheme is calculated. The index with the lowest makespan is chosen and the task is inserted at the index. This process is repeated for each removed task until all tasks are in the activity list. At this point the resulting schedule makespan is compared to the initial schedule makespan and when an improved makespan has been found the initial schedule is overwritten by the new schedule.

This heuristic solution can any number of iterations of the destruction and construction phases until either a iterations limit is reached or a time limit is reached. At that point it will return the most optimal schedule it has found.


\subsection{CNF Encoding}
The conjunctive normal form encoding used for this research is based on existing work used to solve the RCPSP with SAT \cite{RN17}. This encoding was altered to include preemption.

For the new encoding a project has to be extended into a new network \(N^*\) by replacing each task with a new network of tasks that represents all possible ways the task could be preempted. This extension has already been documented but a short summary will be given \cite{RN1}. A task will be split into a set of all possible integer segments. From this new set of segments all chains of segments are generated that represent the original task in its entirety. These chains can now replace the original task in the task network. All segments are added as new tasks with precedence relations representing the segment chains. All predecessors of the task get an additional successor for each segment that contains the first integer part of the original task. Each of the segments that contain the last integer part of the original task must also have the original successors of the task.

With the extended network the earliest \(es_i\) and its latest \(ls_i\) start times, its ealiest \(ef_i\) and its latest \(lf_i\) finish times are calculated using the critical-part method by the Floyd-Warshall algorithm \cite{RN53}. With these values two boolean variables will be defined and used in the SAT clauses. For each task \(i \in N\) and \(t \in \{es_i,...,ls_i\}\) there is a start variable \(s_{i,t}\) which is true if activity \(i\) start at time \(t\) and for east task \(i \in N\) and \(t \in \{es_i,...,lf_i\}\) a process variable \(u_{i,t}\) which is true if activity \(i\) is in process at time \(t\).

Now the complete encoding can be made and it includes five types of clauses. The completion, consistency, precedence, resource and objective clauses. The first four are defined as hard clauses meaning the SAT solver must satisfy them. For the objective a set of soft clauses is used. The SAT solver will try and maximize the amount of soft clauses it can satisfy.

Completion clauses make sure that each task segment is processed once and therefore making sure that all the work in the project is done. New subsets are required to define the completion clauses. \(C^*_{i,l} \subseteq N^*\) each have as elements all task segments that contain time segment \(l\) of task \(i\). Equation \ref{eq:equation2} gives the mathematical definition of the completion clauses.
\begin{align}\label{eq:equation2}
\bigvee_{t\in {es_i,...,ls_i}} s_{it}   &&  j\in N; l\in \{0,...,d_j\}; i\in C^*_{j,l}
\end{align}

When a start variable of a task is set to true the consistency clauses given in equation \ref{eq:equation3} ensure that the required process variables of the task are also set to true.
\begin{align}\label{eq:equation3}
\neg s_{i,t} \vee u_{i,l}   &&  i\in N^*;t\in \{es_i,...,ls_i\};l\in \{t,...,t+d_i-1\}
\end{align}

A set of precedence clauses is introduced to satisfy the required precedence constraints. This is done by only allowing a task to have a start variable set to true if all predecessors started early enough to be finished by that time. This clause is given in equation \ref{eq:equation4}.
\begin{align}\label{eq:equation4}
\neg s_{i,t} \bigvee_{l=es_j,...,es_i-d_j} s_{j,l}  &&  (j,i)\in A; t\in\{es_i,...,ls_i\}
\end{align}

The resource clauses are defined as pseudo-boolean function that are converted into true CNF. The conversion is done by first building binary decision diagrams from the pseudo-boolean function. Next the binary decision diagrams are converted to a set of CNF clauses that represent the same pseudo-boolean function. The process of converting pseudo-boolean into SAT is known and researched \cite{RN38}. The used pseudo-boolean function is given in equation \ref{eq:equation5}.
\begin{align}\label{eq:equation5}
\sum^n_{i=1} u_{i,t}r_{i,k} \leq a_k    &&  t\in \{1,...,T\}; k\in R
\end{align}

Lastly there are the objective clauses in equation \ref{eq:equation6}. These are soft clauses and the SAT solver tries to satisfy as many of these clauses as possible.
\begin{align}\label{eq:equation6}
s_{i,t} &&  t\in \{1,...,T\}; i = \text{dummy finish task}
\end{align}

When this encoding is done the result is run on the Pumpkin MAX-SAT solver that was provided to the research by supervisor Emir DemiroviÄ‡.

% \subsection{SAT solver}
% Due to difficulties during the CNF encoding my current planning does not allow for any time spent on improving the SAT solver.